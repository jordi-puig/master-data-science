coef(sfo.model2)
# el valor de R squared
summary(sfo.model2)$r.squared
# creem les dues mostres
sfo.clean.long <- subset(sfo.clean, sfo.clean$DISTANCE > 600)
sfo.clean.short <- subset(sfo.clean, sfo.clean$DISTANCE <= 600)
# obtenim les dades del model i el valor de R squared
sfo.shortdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.short)
coef(sfo.shortdistance.model)
# el valor de R squared
summary(sfo.shortdistance.model)$r.squared
# obtenim les dades del model i el valor de R squared
sfo.longdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.long)
coef(sfo.longdistance.model)
# el valor de R squared
summary(sfo.longdistance.model)$r.squared
sfo.clean <- subset(sfo.clean, !is.na(sfo.clean$LATE_AIRCRAFT_DELAY))
sfo.clean$LATE_AIRCRAFT_DELAY_BOOL <- ifelse(sfo.clean$LATE_AIRCRAFT_DELAY > 15, 1, 0)
sfo.model3 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + LATE_AIRCRAFT_DELAY_BOOL, data = sfo.clean)
coef(sfo.model3)
summary(sfo.model3)$r.squared
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
sfo.clean$yi<- 2.35 + (9.246e-01 * sfo.clean$ARRIVAL_DELAY) + (2.904e-03 * sfo.clean$DISTANCE)
sfo.clean$ri <- sfo.clean$DEPARTURE_DELAY - sfo.clean$yi
plot(x = sfo.clean$yi, y = sfo.clean$ri)
plot(x = sfo.clean$DEPARTURE_DELAY, y = sfo.clean$ri)
plot(x = sfo.clean$DISTANCE, y = sfo.clean$ri)
model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data=sfo.clean)
summary(model)
model.stdres = rstandard(model)
qqnorm(model.stdres,
ylab="Standardized Residuals",
xlab="Normal Scores",
main="QQ Plot")
qqline(model.stdres)
prediction.departure.delay <- 2.35 + (9.246e-01 * 30) + (2.904e-03 * 2500)
paste('Segons el model que hem calculat l\'avió sortirà amb un retard de:',prediction.departure.delay, 'minuts')
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
sfo.delay$DAY_OF_WEEK_STR <- as.factor(sfo.delay$DAY_OF_WEEK_STR)
sfo.delay$DAY_OF_WEEK_STR <- as.factor(sfo.delay$DAY_OF_WEEK_STR)
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
Transformem els atributs com a factor:
```{r}
sfo.delay$DAY_OF_WEEK_STR <- as.factor(sfo.delay$DAY_OF_WEEK_STR)
sfo.delay$DAY_OF_WEEK <- as.factor(sfo.delay$DAY_OF_WEEK)
sfo.delay$DELAY_SFO <- as.factor(sfo.delay$DELAY_SFO)
sfo.delay$AIRLINE <- as.factor(sfo.delay$AIRLINE)
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK, fill=DELAY_SFO)) + geom_bar(position="fill")
ggplot(data=sfo.delay,aes(x=AIRLINE,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=AIRLINE, fill=DELAY_SFO)) + geom_bar(position="fill") + ylab("Probability")
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DEPARTURE_DELAY)
table
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DELAY_SFO)
table
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
test <- chisq.test(table, correct=FALSE)
test.all()
test.all
test1 <- chisq.test(table, correct=FALSE)
test1$statistic
test1$method
test1$observed
test1$expected
test1$residuals
chisq.test(table, correct=FALSE)
table <-table(sfo.delay$AIRLINE, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
MONDAY_REL <- relevel(sfo.delay$DAY_OF_WEEK, ref = '1')
head(MONDAY_REL)
model.logist1=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK, family=binomial(link=logit))
summary(model.logist1)
head(sfo.delay$DAY_OF_WEEK)
summary(sfo.delay$DAY_OF_WEEK)
model.logist1=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist1)
model.logist2=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist2)
model.logist3=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist3)
knitr::opts_chunk$set(eval=T, echo=T)
library(dplyr)
library(base)
library(matrixStats)
library(stringr)
library(ggplot2)
library(lubridate)
library(eeptools)
library(psych)
library(corrplot)
library(factoextra)
library(ggbiplot)
library(ggpubr)
library(rlang)
library(kableExtra)
install.packages("ResourceSelection", repos="http://R-Forge.R-project.org")
library(ResourceSelection)
library(pROC)
sfo <- read.csv('SFO.csv',stringsAsFactors = TRUE, sep = ',')
attach(sfo) # ens permet referenciar les columnes de fifa sense haver d'especificar el dataset.
summary(sfo)
cat('Tenim un total de', ncol(sfo), 'columnes')
cat('Tenim un total de', nrow(sfo), 'registres')
colSums(is.na(sfo))
head(sfo)
str(sfo)
plot(x = sfo$ARRIVAL_DELAY, y = sfo$DEPARTURE_DELAY)
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
mean.x <- mean(sfo.clean$ARRIVAL_DELAY)
paste('La mitjana mostral de ARRIVAL_DELAY és:', round(mean.x, 3))
mean.y <- mean(sfo.clean$DEPARTURE_DELAY)
paste('La mitjana mostral de DEPARTURE_DELAY és:', round(mean.y, 3))
# calculem les diferencies entre valors observats (xi) i la mitjana mostral de x
xi.x <- sfo.clean$ARRIVAL_DELAY - mean.x
# fem el mateix per els valors de y
yi.y <- sfo.clean$DEPARTURE_DELAY - mean.y
# calculem el sumatori del producte
SXY <- sum(xi.x * yi.y) / (nrow(sfo.clean) - 1)
paste('El valor de la covariància mostral és:', round(SXY, 3))
# fem el càlcul amb la funció cov i obtenim el mateix resultat
SXY <- cov(sfo.clean$DEPARTURE_DELAY, sfo.clean$ARRIVAL_DELAY)
paste('El valor de la covariància mostral amb la funció cov és:', round(SXY, 3))
# calculem el sumatori de la diferencies entre xi - mitjana mostral de x al quadrat
xi.x2 <- sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2)
S2 <- xi.x2 / (nrow(sfo.clean) - 1)
paste('El valor de la variància mostral és:', round(S2, 3))
# calculem amb la funció var
S2 <- var(sfo.clean$ARRIVAL_DELAY)
paste('El valor de la variància mostral amb la funció var és:', round(S2, 3))
# Interpretació de l’ordenada a l’origen:
B1 <- SXY / S2
paste('La interpretació de l’ordenada a l’origen és (B1): ', round(B1, 3))
# Interpretació del pendent de la recta:
B0 <- mean.y - B1 * mean.x
paste('La interpretació del pendent de la recta (B0): ', round(B0, 3))
# La recta de regressió queda de la forma següent:
paste('y =', round(B0, 3), '+', round(B1, 3),'x')
SQT <- sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2)
paste('La suma de quadrats totals és:', SQT)
# calculem els valors estimats
y.estimate <- (B1* sfo.clean$ARRIVAL_DELAY + B0)
SQR <- sum((y.estimate - mean.y)^2)
paste('La suma de quadrats de la regressió:', SQR)
SQE <- SQT - SQR
paste('La suma de quadrats dels errors:', SQE)
R_square = SQR / SQT
paste('El coeficient de determinació és:', round(R_square, 3))
# altre forma de calcular-ho
R_square = 1 - (SQE / SQT)
paste('El coeficient de determinació és:', round(R_square, 3))
xi.x2 <- sqrt(sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2) / nrow(sfo.clean))
yi.y2 <- sqrt(sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2) / nrow(sfo.clean))
r <- (SXY) / (xi.x2 * yi.y2)
paste('El coeficient de correlació mostral és de:', round(r,3))
r*r
sfo.model1 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY, data = sfo.clean)
coef(sfo.model1)
summary(sfo.model1)$r.squared
plot(x = sfo$DISTANCE, y = sfo$DEPARTURE_DELAY)
# nombre de files
n <- nrow(sfo.clean)
# montem la matriu X amb els valors de les files ARRIVAL_DELAY i DISTANCE (explicatives)
X <- cbind(rep(1, n), sfo.clean$ARRIVAL_DELAY, sfo.clean$DISTANCE)
# montem el vector de sortida que és la variable DEPARTURE_DELAY
y = sfo.clean$DEPARTURE_DELAY
# executem les funcions matricials
beta <- solve(t(X) %*% X) %*% t(X) %*% y
paste('B0 és', round(beta[1],3), 'B1 és: ', round(beta[2],3), 'B2 és: ', round(beta[3],3))
# calculem el vector de les desviacions de y respecte la mitjana de y i el SQT
D <- sfo.clean$DEPARTURE_DELAY - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQT és la matriu trasposada de D x D
SQT <- t(D) %*% D
# calculem el vector de les desviacions de yi (és a dir els valors de DEPARTURE_DELAY a partir del model càlculat) respecte la mitjana de y
B0 <- beta[1]
B1 <- beta[2]
B2 <- beta[3]
yi <- B0 + (B1 * sfo.clean$ARRIVAL_DELAY) + (B2 * sfo.clean$DISTANCE)
w <- yi - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQR és la matriu trasposada de w x w
SQR <- t(w) %*% w
# i ara ja podem saber el valor de R²
R_square <- SQR / SQT
paste('El valor del coeficient de determinació del model calculat és: ', R_square)
# els valors de la recta
sfo.model2 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean)
coef(sfo.model2)
# el valor de R squared
summary(sfo.model2)$r.squared
# creem les dues mostres
sfo.clean.long <- subset(sfo.clean, sfo.clean$DISTANCE > 600)
sfo.clean.short <- subset(sfo.clean, sfo.clean$DISTANCE <= 600)
# obtenim les dades del model i el valor de R squared
sfo.shortdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.short)
coef(sfo.shortdistance.model)
# el valor de R squared
summary(sfo.shortdistance.model)$r.squared
# obtenim les dades del model i el valor de R squared
sfo.longdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.long)
coef(sfo.longdistance.model)
# el valor de R squared
summary(sfo.longdistance.model)$r.squared
sfo.clean <- subset(sfo.clean, !is.na(sfo.clean$LATE_AIRCRAFT_DELAY))
sfo.clean$LATE_AIRCRAFT_DELAY_BOOL <- ifelse(sfo.clean$LATE_AIRCRAFT_DELAY > 15, 1, 0)
sfo.model3 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + LATE_AIRCRAFT_DELAY_BOOL, data = sfo.clean)
coef(sfo.model3)
summary(sfo.model3)$r.squared
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
sfo.clean$yi<- 2.35 + (9.246e-01 * sfo.clean$ARRIVAL_DELAY) + (2.904e-03 * sfo.clean$DISTANCE)
sfo.clean$ri <- sfo.clean$DEPARTURE_DELAY - sfo.clean$yi
plot(x = sfo.clean$yi, y = sfo.clean$ri)
plot(x = sfo.clean$DEPARTURE_DELAY, y = sfo.clean$ri)
plot(x = sfo.clean$DISTANCE, y = sfo.clean$ri)
model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data=sfo.clean)
summary(model)
model.stdres = rstandard(model)
qqnorm(model.stdres,
ylab="Standardized Residuals",
xlab="Normal Scores",
main="QQ Plot")
qqline(model.stdres)
prediction.departure.delay <- 2.35 + (9.246e-01 * 30) + (2.904e-03 * 2500)
paste('Segons el model que hem calculat l\'avió sortirà amb un retard de:',prediction.departure.delay, 'minuts')
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
sfo.delay$DAY_OF_WEEK <- as.factor(sfo.delay$DAY_OF_WEEK)
sfo.delay$DELAY_SFO <- as.factor(sfo.delay$DELAY_SFO)
sfo.delay$AIRLINE <- as.factor(sfo.delay$AIRLINE)
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK, fill=DELAY_SFO)) + geom_bar(position="fill")
ggplot(data=sfo.delay,aes(x=AIRLINE,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=AIRLINE, fill=DELAY_SFO)) + geom_bar(position="fill") + ylab("Probability")
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
table <-table(sfo.delay$AIRLINE, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
model.logist1=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK, family=binomial(link=logit))
summary(model.logist1)
confint(model.logist1)
exp(coefficients(model.logist1))
model.logist2=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist2)
confint(model.logist2)
exp(coefficients(model.logist2))
model.logist3=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE, family=binomial(link=logit))
summary(model.logist3)
exp(coefficients(model.logist3))
model.logist4=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$AIRLINE , family=binomial(link=logit))
summary(model.logist4)
exp(coefficients(model.logist4))
data <- data.frame(DAY_OF_WEEK='4',DISTANCE=1500)
pred<-predict(model.logist3, data,type ="response")
pred
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
prob=predict(model.logist3, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot (r)
auc(r)
prob=predict(model.logist4, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot (r)
auc(r)
cat('Tenim un total de', ncol(sfo), 'columnes\n')
cat('Tenim un total de', nrow(sfo), 'registres')
cat('Tenim un total de', ncol(sfo), 'columnes\n')
cat('Tenim un total de', nrow(sfo), 'registres')
colSums(is.na(sfo))
# Interpretació de l’ordenada a l’origen:
B1 <- SXY / S2
paste('La interpretació de l’ordenada a l’origen és (B1): ', round(B1, 3))
# Interpretació del pendent de la recta:
B0 <- mean.y - B1 * mean.x
paste('La interpretació del pendent de la recta (B0): ', round(B0, 3))
knitr::opts_chunk$set(eval=T, echo=T)
data <- data.frame(DAY_OF_WEEK='4',DISTANCE=1500)
pred<-predict(model.logist3, data,type ="response")
pred
model.logist.predict=glm(data=sfo.delay, formula=DELAY_SFO ~ DAY_OF_WEEK + DISTANCE, family=binomial(link=logit))
data <- data.frame(DAY_OF_WEEK='4',DISTANCE=1500)
pred<-predict(model.logist.predict, data,type ="response")
pred
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
library(ResourceSelection)
library(ResourceSelection)
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
model.logist.last=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE + sfo.delay$DISTANCE, family=binomial(link=logit))
prob=predict(model.logist.last, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
knitr::opts_chunk$set(eval=T, echo=T)
library(dplyr)
library(base)
library(matrixStats)
library(stringr)
library(ggplot2)
library(lubridate)
library(eeptools)
library(psych)
library(corrplot)
library(factoextra)
library(ggbiplot)
library(ggpubr)
library(rlang)
library(kableExtra)
install.packages("ResourceSelection", repos="http://R-Forge.R-project.org")
library(ResourceSelection)
library(pROC)
sfo <- read.csv('SFO.csv',stringsAsFactors = TRUE, sep = ',')
attach(sfo) # ens permet referenciar les columnes de fifa sense haver d'especificar el dataset.
summary(sfo)
knitr::opts_chunk$set(eval=T, echo=T)
model.logist.last=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE + sfo.delay$AIRLANE, family=binomial(link=logit))
model.logist.last=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE + sfo.delay$AIRLANE, family=binomial(link=logit))
sfo.delay <- subset(sfo.delay, !is.na(sfo.delay$AIRLINE))
model.logist.last=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE + sfo.delay$AIRLANE, family=binomial(link=logit))
knitr::opts_chunk$set(eval=T, echo=T)
library(dplyr)
library(base)
library(matrixStats)
library(stringr)
library(ggplot2)
library(lubridate)
library(eeptools)
library(psych)
library(corrplot)
library(factoextra)
library(ggbiplot)
library(ggpubr)
library(rlang)
library(kableExtra)
install.packages("ResourceSelection", repos="http://R-Forge.R-project.org")
library(ResourceSelection)
library(pROC)
sfo <- read.csv('SFO.csv',stringsAsFactors = TRUE, sep = ',')
attach(sfo) # ens permet referenciar les columnes de fifa sense haver d'especificar el dataset.
summary(sfo)
cat('Tenim un total de', ncol(sfo), 'columnes\n')
cat('Tenim un total de', nrow(sfo), 'registres')
colSums(is.na(sfo))
head(sfo)
str(sfo)
plot(x = sfo$ARRIVAL_DELAY, y = sfo$DEPARTURE_DELAY)
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
mean.x <- mean(sfo.clean$ARRIVAL_DELAY)
paste('La mitjana mostral de ARRIVAL_DELAY és:', round(mean.x, 3))
mean.y <- mean(sfo.clean$DEPARTURE_DELAY)
paste('La mitjana mostral de DEPARTURE_DELAY és:', round(mean.y, 3))
# calculem les diferencies entre valors observats (xi) i la mitjana mostral de x
xi.x <- sfo.clean$ARRIVAL_DELAY - mean.x
# fem el mateix per els valors de y
yi.y <- sfo.clean$DEPARTURE_DELAY - mean.y
# calculem el sumatori del producte
SXY <- sum(xi.x * yi.y) / (nrow(sfo.clean) - 1)
paste('El valor de la covariància mostral és:', round(SXY, 3))
# fem el càlcul amb la funció cov i obtenim el mateix resultat
SXY <- cov(sfo.clean$DEPARTURE_DELAY, sfo.clean$ARRIVAL_DELAY)
paste('El valor de la covariància mostral amb la funció cov és:', round(SXY, 3))
# calculem el sumatori de la diferencies entre xi - mitjana mostral de x al quadrat
xi.x2 <- sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2)
S2 <- xi.x2 / (nrow(sfo.clean) - 1)
paste('El valor de la variància mostral és:', round(S2, 3))
# calculem amb la funció var
S2 <- var(sfo.clean$ARRIVAL_DELAY)
paste('El valor de la variància mostral amb la funció var és:', round(S2, 3))
# Interpretació de l’ordenada a l’origen:
B1 <- SXY / S2
paste('La interpretació de l’ordenada a l’origen és (B1): ', round(B1, 3))
# Interpretació del pendent de la recta:
B0 <- mean.y - B1 * mean.x
paste('La interpretació del pendent de la recta (B0): ', round(B0, 3))
# La recta de regressió queda de la forma següent:
paste('y =', round(B0, 3), '+', round(B1, 3),'x')
SQT <- sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2)
paste('La suma de quadrats totals és:', SQT)
# calculem els valors estimats
y.estimate <- (B1* sfo.clean$ARRIVAL_DELAY + B0)
SQR <- sum((y.estimate - mean.y)^2)
paste('La suma de quadrats de la regressió:', SQR)
SQE <- SQT - SQR
paste('La suma de quadrats dels errors:', SQE)
R_square = SQR / SQT
paste('El coeficient de determinació és:', round(R_square, 3))
# altre forma de calcular-ho
R_square = 1 - (SQE / SQT)
paste('El coeficient de determinació és:', round(R_square, 3))
xi.x2 <- sqrt(sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2) / nrow(sfo.clean))
yi.y2 <- sqrt(sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2) / nrow(sfo.clean))
r <- (SXY) / (xi.x2 * yi.y2)
paste('El coeficient de correlació mostral és de:', round(r,3))
r*r
sfo.model1 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY, data = sfo.clean)
coef(sfo.model1)
summary(sfo.model1)$r.squared
plot(x = sfo$DISTANCE, y = sfo$DEPARTURE_DELAY)
# nombre de files
n <- nrow(sfo.clean)
# montem la matriu X amb els valors de les files ARRIVAL_DELAY i DISTANCE (explicatives)
X <- cbind(rep(1, n), sfo.clean$ARRIVAL_DELAY, sfo.clean$DISTANCE)
# montem el vector de sortida que és la variable DEPARTURE_DELAY
y = sfo.clean$DEPARTURE_DELAY
# executem les funcions matricials
beta <- solve(t(X) %*% X) %*% t(X) %*% y
paste('B0 és', round(beta[1],3), 'B1 és: ', round(beta[2],3), 'B2 és: ', round(beta[3],3))
# calculem el vector de les desviacions de y respecte la mitjana de y i el SQT
D <- sfo.clean$DEPARTURE_DELAY - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQT és la matriu trasposada de D x D
SQT <- t(D) %*% D
# calculem el vector de les desviacions de yi (és a dir els valors de DEPARTURE_DELAY a partir del model càlculat) respecte la mitjana de y
B0 <- beta[1]
B1 <- beta[2]
B2 <- beta[3]
yi <- B0 + (B1 * sfo.clean$ARRIVAL_DELAY) + (B2 * sfo.clean$DISTANCE)
w <- yi - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQR és la matriu trasposada de w x w
SQR <- t(w) %*% w
# i ara ja podem saber el valor de R²
R_square <- SQR / SQT
paste('El valor del coeficient de determinació del model calculat és: ', R_square)
# els valors de la recta
sfo.model2 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean)
coef(sfo.model2)
# el valor de R squared
summary(sfo.model2)$r.squared
# creem les dues mostres
sfo.clean.long <- subset(sfo.clean, sfo.clean$DISTANCE > 600)
sfo.clean.short <- subset(sfo.clean, sfo.clean$DISTANCE <= 600)
# obtenim les dades del model i el valor de R squared
sfo.shortdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.short)
coef(sfo.shortdistance.model)
# el valor de R squared
summary(sfo.shortdistance.model)$r.squared
# obtenim les dades del model i el valor de R squared
sfo.longdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.long)
coef(sfo.longdistance.model)
# el valor de R squared
summary(sfo.longdistance.model)$r.squared
sfo.clean <- subset(sfo.clean, !is.na(sfo.clean$LATE_AIRCRAFT_DELAY))
sfo.clean$LATE_AIRCRAFT_DELAY_BOOL <- ifelse(sfo.clean$LATE_AIRCRAFT_DELAY > 15, 1, 0)
sfo.model3 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + LATE_AIRCRAFT_DELAY_BOOL, data = sfo.clean)
coef(sfo.model3)
summary(sfo.model3)$r.squared
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
sfo.clean$yi<- 2.35 + (9.246e-01 * sfo.clean$ARRIVAL_DELAY) + (2.904e-03 * sfo.clean$DISTANCE)
sfo.clean$ri <- sfo.clean$DEPARTURE_DELAY - sfo.clean$yi
plot(x = sfo.clean$yi, y = sfo.clean$ri)
plot(x = sfo.clean$DEPARTURE_DELAY, y = sfo.clean$ri)
plot(x = sfo.clean$DISTANCE, y = sfo.clean$ri)
model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data=sfo.clean)
summary(model)
model.stdres = rstandard(model)
qqnorm(model.stdres,
ylab="Standardized Residuals",
xlab="Normal Scores",
main="QQ Plot")
qqline(model.stdres)
prediction.departure.delay <- 2.35 + (9.246e-01 * 30) + (2.904e-03 * 2500)
paste('Segons el model que hem calculat l\'avió sortirà amb un retard de:',prediction.departure.delay, 'minuts')
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
sfo.delay$DAY_OF_WEEK <- as.factor(sfo.delay$DAY_OF_WEEK)
sfo.delay$DELAY_SFO <- as.factor(sfo.delay$DELAY_SFO)
sfo.delay$AIRLINE <- as.factor(sfo.delay$AIRLINE)
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK, fill=DELAY_SFO)) + geom_bar(position="fill")
ggplot(data=sfo.delay,aes(x=AIRLINE,fill=DELAY_SFO)) + geom_bar()
ggplot(data=sfo.delay,aes(x=AIRLINE, fill=DELAY_SFO)) + geom_bar(position="fill") + ylab("Probability")
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
table <-table(sfo.delay$AIRLINE, sfo.delay$DELAY_SFO)
table
chisq.test(table, correct=FALSE)
model.logist1=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK, family=binomial(link=logit))
summary(model.logist1)
confint(model.logist1)
exp(coefficients(model.logist1))
model.logist2=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist2)
confint(model.logist2)
exp(coefficients(model.logist2))
model.logist3=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE, family=binomial(link=logit))
summary(model.logist3)
exp(coefficients(model.logist3))
model.logist4=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$AIRLINE , family=binomial(link=logit))
summary(model.logist4)
exp(coefficients(model.logist4))
model.logist.predict=glm(data=sfo.delay, formula=DELAY_SFO ~ DAY_OF_WEEK + DISTANCE, family=binomial(link=logit))
data <- data.frame(DAY_OF_WEEK='4',DISTANCE=1500)
pred<-predict(model.logist.predict, data,type ="response")
pred
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
prob=predict(model.logist3, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot (r)
auc(r)
prob=predict(model.logist4, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot(r)
auc(r)
