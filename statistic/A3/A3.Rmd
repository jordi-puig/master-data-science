---
title: 'Estadística Avançada'
author: "Autor: Jordi Puig Ovejero"
date: "Març 2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
```

Carrega de les llibreries que es necessiten 
```{r message= FALSE, warning=FALSE}
library(dplyr)
library(base)
library(matrixStats)
library(stringr)
library(ggplot2)
library(lubridate)
library(eeptools)
library(psych)
library(corrplot)
library(factoextra)
library(ggbiplot)
library(ggpubr)
library(rlang)
library(kableExtra)
install.packages("ResourceSelection", repos="http://R-Forge.R-project.org")
library(ResourceSelection)
library(pROC)
```

******
# Lectura del fitxer
******

El fitxer on es troba el dataset és, **SFO.csv**:

Carreguem les dades i fem un summary d'aquestes.
```{r message= FALSE, warning=FALSE}
sfo <- read.csv('SFO.csv',stringsAsFactors = TRUE, sep = ',')
attach(sfo) # ens permet referenciar les columnes de fifa sense haver d'especificar el dataset.
summary(sfo)
```


Contem les files i columnes que tenim.
```{r message= FALSE, warning=FALSE}
cat('Tenim un total de', ncol(sfo), 'columnes\n')
cat('Tenim un total de', nrow(sfo), 'registres')
```

I mostrem els valors NA per cada atribut.
```{r message= FALSE, warning=FALSE}
colSums(is.na(sfo))
```
Finalment fem un head dels atributs a tractar.

```{r}
head(sfo)
```


Amb una ràpida ullada podem dir que: 

* Nombre de registres: 145952
* Nombre d'atributs totals: 28
* Tenim valors NA a: WHEELS_OFF, ELAPSED_TIME, WEATHER_DELAY, AIR_TIME, WHEELS_ON, TAXI_IN, ARRIVAL_TIME, ARRIVAL_DELAY, LATE_AIRCRAFT_DELAY i WEATHER_DELAY.

## Definició dels atributs importants

* Month: Dia del mes de sortida del vol.
* Day of week: Dia de la setmana de sortida del vol.
* Airline: Nom en sigles de la companyia aèria.
* Destination Airport: Aeroport de destinació.
* Scheduled Departure: Hora de sortida del vol estimada per la companyia.
* Departure Time: Hora de sortida real del vol.
* Departure Delay: Diferència entre l’hora de sortida estimada i la real.
* Air Time: Temps real de vol en aire.
* Distance: Distància entre els aeroports origen i arribada.
* Scheduled Arrival: Hora d’arribada del vol estimada per la companyia.
* Arrival Time: Hora d’arribada del vol.
* Arrival Delay: Diferència entre l’hora d’arribada estimada i la real.
* Late Aircraft Delay: Retard per arribada tard de l’avió.
* Diverted: Indicador de vol desviat, sent zero si el vol s’ha efectuat amb normalitat i un si ha estat desviat.
* Cancelled: Indicador de vol cancel·lat, sent zero si el vol s’ha efectuat i un si no.

## Classes del atributs del dataframe

Anem a comprovar les classes dels atributs del dataframe

```{r}
str(sfo)
```
Veiem que tenim algunes dades com a quantitatives i altres com a qualitatives. Segons exercici i la necessitat realitzarem transformacions.

*****
# Model de regressió lineal
*****

## Model de regressió lineal (regresors quantitatius)

### a. Model lineal de la variable DEPARTURE_DELAY en funció de la variable ARRIVAL_DELAY.

En l'exercici volem trobar una funció que ens expliqui la variable DEPARTURE_DELAY en funció de la variable ARRIVAL_DELAY.

Diagrama de dispersió. Amb el diagrama podem observar si hi ha una relació entre les variables de forma visual:

```{r}
plot(x = sfo$ARRIVAL_DELAY, y = sfo$DEPARTURE_DELAY)
```

Rápidament és veu una relació molt clara entre les dues variables. Conforme creix el valor d'ARRIVAL_DELAY, creix DEPARTURE_DELAY.


Anem a trobar l'equació de la recta de regressió (y = a + bx). Estimem els paràmetres (a,b) a partir del mètode dels mínims quadrats on la suma dels quadrats dels residus (errors) sigui mínima.


Eliminem els valors nulls d'ARRIVAL_DELAY

```{r}
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
```

Anem a calcular les **mitjanes mostrals**:

```{r}
mean.x <- mean(sfo.clean$ARRIVAL_DELAY)
paste('La mitjana mostral de ARRIVAL_DELAY és:', round(mean.x, 3))

mean.y <- mean(sfo.clean$DEPARTURE_DELAY)
paste('La mitjana mostral de DEPARTURE_DELAY és:', round(mean.y, 3))
```

Càlculem la **covariància mostral**.

```{r}
# calculem les diferencies entre valors observats (xi) i la mitjana mostral de x
xi.x <- sfo.clean$ARRIVAL_DELAY - mean.x

# fem el mateix per els valors de y
yi.y <- sfo.clean$DEPARTURE_DELAY - mean.y

# calculem el sumatori del producte
SXY <- sum(xi.x * yi.y) / (nrow(sfo.clean) - 1)
paste('El valor de la covariància mostral és:', round(SXY, 3))

# fem el càlcul amb la funció cov i obtenim el mateix resultat
SXY <- cov(sfo.clean$DEPARTURE_DELAY, sfo.clean$ARRIVAL_DELAY)
paste('El valor de la covariància mostral amb la funció cov és:', round(SXY, 3))

```
El valor positiu tan gran ens indica que hi ha una relació molt directa entre les variables (sino seria proper a 0) en sentit positiu (conforme creix una variable, creix l'altre)

Ara calcularem la **variància mostral**. Podem fer-ho de dues formes

```{r}
# calculem el sumatori de la diferencies entre xi - mitjana mostral de x al quadrat
xi.x2 <- sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2)
S2 <- xi.x2 / (nrow(sfo.clean) - 1)
paste('El valor de la variància mostral és:', round(S2, 3))

# calculem amb la funció var
S2 <- var(sfo.clean$ARRIVAL_DELAY)
paste('El valor de la variància mostral amb la funció var és:', round(S2, 3))
```

Paràmetres de la recta:

```{r}
# Interpretació de l’ordenada a l’origen:
B1 <- SXY / S2
paste('La interpretació de l’ordenada a l’origen és (B1): ', round(B1, 3))

# Interpretació del pendent de la recta:
B0 <- mean.y - B1 * mean.x
paste('La interpretació del pendent de la recta (B0): ', round(B0, 3))
```

Recta de regressió:

```{r}
# La recta de regressió queda de la forma següent:
paste('y =', round(B0, 3), '+', round(B1, 3),'x')

```

Ara, un cop tenim la recta de regressió, volem saber quin és l'error que hi ha entre el valor real i el calculat a partir de la recta. Això ho farem calculant SQT, SQR i SQE:

SQT (Suma de quadrats totals). Necessitem el valors observats i la mitjana mostral.

```{r}
SQT <- sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2)
paste('La suma de quadrats totals és:', SQT)
```

SQR (Suma de quadrats de la regressió). Per calcular la suma de quadrats de la regressió necessitem els valors estimat i la mitjana mostral. 

```{r}
# calculem els valors estimats
y.estimate <- (B1* sfo.clean$ARRIVAL_DELAY + B0)

SQR <- sum((y.estimate - mean.y)^2)
paste('La suma de quadrats de la regressió:', SQR)
```

SQE (Suma de quadrats dels errors):

```{r}
SQE <- SQT - SQR
paste('La suma de quadrats dels errors:', SQE)
```

Amb aquestes dades podem calcular el coeficient de determinació (R²):

```{r}
R_square = SQR / SQT
paste('El coeficient de determinació és:', round(R_square, 3))

# altre forma de calcular-ho
R_square = 1 - (SQE / SQT)
paste('El coeficient de determinació és:', round(R_square, 3))
```

Quant més aprop estigui R² del valor 1 més variabilitat està explicada en la recta de regressió i per tant més fortament relacionades están les variables tractades. Tenim un valor molt proper a 1, com hem comentat previament, indica que hi ha una forta relació entre les variables. 

Aquest coeficient de determinació de més de 0,908 ens diu que el model de regressió ens explica més del 90% de la variància de les observacions. Té sentit ja que el retard en les sortides està influenciat per el retard en les arrivades prèvies.

El coeficient de correlació mostral (r):

```{r}
xi.x2 <- sqrt(sum((sfo.clean$ARRIVAL_DELAY - mean.x)^2) / nrow(sfo.clean))

yi.y2 <- sqrt(sum((sfo.clean$DEPARTURE_DELAY - mean.y)^2) / nrow(sfo.clean))

r <- (SXY) / (xi.x2 * yi.y2)

paste('El coeficient de correlació mostral és de:', round(r,3))
```
Amb un valor tan proper a 1, podem dir que tenim una relació entre les variables prou forta.

Sabem que:

* R²: mesura la proporció de variació de la variable dependent explicada per la variable independent.

* r: mesura el grau d’associació entre les dues variables.

Però en la regressió lineal simple R² = r².

```{r}
r*r
```
Al ser positiu el valor de r ens diu que al augmentar el valor d'ARRIVAL_DELAY també augmentarà el valor de DEPARTURE_DELAY.

Si fem els càlculs mitjançant la funció lm de R obtenim els mateixos valors de B0 i B1:

```{r}
sfo.model1 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY, data = sfo.clean)
coef(sfo.model1)

summary(sfo.model1)$r.squared
```

### b. Afegim la variable independent DISTANCE.
  
Ara aplicarem un model de regressió múltiple ja que tindrem dues variables explicatives o independents (ARRIVAL_DELAY i DISTANCE) per inferir la variable depenent o explicada DEPARTURE_DELAY.

Abans hem vist gràficament la relació entre ARRIVAL_DELAY i DEPARTURE_DELAY. Fem el mateix amb DISTANCE:

```{r}
plot(x = sfo$DISTANCE, y = sfo$DEPARTURE_DELAY)
```


No sembla que tinguem una relació lineal entre aquestes dues variables.

Ara farem un procediment similar a l'anterior mitjçant la suma dels residus al quadrat i busquem els paràmetres que fan que aquesta suma sigui mínima.

Busqum una formula amb la firma següent:

yi = B0 + + B1*x1 B2*x2
 
Volem estimar els valors B0, B1, B2. Els x1 i x2 són dues observacions de les variables. Per a fer-ho necessitem mitjançant la formula matricial següent B = solve(t(X) * X) * t(X) * Y on:

* t(X): es la trasposada de X
* solve: calcula la inversa de la matriu


```{r}
# nombre de files
n <- nrow(sfo.clean)

# montem la matriu X amb els valors de les files ARRIVAL_DELAY i DISTANCE (explicatives)
X <- cbind(rep(1, n), sfo.clean$ARRIVAL_DELAY, sfo.clean$DISTANCE)

# montem el vector de sortida que és la variable DEPARTURE_DELAY
y = sfo.clean$DEPARTURE_DELAY

# executem les funcions matricials
beta <- solve(t(X) %*% X) %*% t(X) %*% y
paste('B0 és', round(beta[1],3), 'B1 és: ', round(beta[2],3), 'B2 és: ', round(beta[3],3))
```
Tenim doncs la fórmula següent:

yi = 2.35 + 0.925 * ARRIVAL_DELAY + 0.003 * DISTANCE

Ara anem a comprobar la qualitat del model a partir del coeficient de determinació R² igual que hem fet amb model de regressió simple on SQT = SQR + SQE


```{r}

# calculem el vector de les desviacions de y respecte la mitjana de y i el SQT
D <- sfo.clean$DEPARTURE_DELAY - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQT és la matriu trasposada de D x D
SQT <- t(D) %*% D

# calculem el vector de les desviacions de yi (és a dir els valors de DEPARTURE_DELAY a partir del model càlculat) respecte la mitjana de y
B0 <- beta[1]
B1 <- beta[2]
B2 <- beta[3]
yi <- B0 + (B1 * sfo.clean$ARRIVAL_DELAY) + (B2 * sfo.clean$DISTANCE)
w <- yi - mean(sfo.clean$DEPARTURE_DELAY)
# ara sabem que SQR és la matriu trasposada de w x w
SQR <- t(w) %*% w

# i ara ja podem saber el valor de R²
R_square <- SQR / SQT
paste('El valor del coeficient de determinació del model calculat és: ', R_square)
```


Per a comprobar que els càlculs realitzats són correctes anem a tornar a executar la funció lm:

```{r}
# els valors de la recta
sfo.model2 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean)
coef(sfo.model2)

# el valor de R squared
summary(sfo.model2)$r.squared
```
La millora en la qualitat del model és realment molt petita. La variable DISTANCE està aportant molt poc a la explicació de la variable dependent DEPARTURE_DELAY. Ja ens havia semblat en el plot que hem vist que no hi havia molta relació entre ambdues variables. De totes formes el conjunt de les variables ARRIVAL_DELAY + DISTANCE aporta més d'un 91% de la variabilitat total.

### c. Dividim la mostra per distància.

Dividim la mostra en dos datasets, un amb vols més llargs de 600 milles i vols més curts o iguals a 600 milles.

```{r}
# creem les dues mostres
sfo.clean.long <- subset(sfo.clean, sfo.clean$DISTANCE > 600)
sfo.clean.short <- subset(sfo.clean, sfo.clean$DISTANCE <= 600)

# obtenim les dades del model i el valor de R squared
sfo.shortdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.short)
coef(sfo.shortdistance.model)

# el valor de R squared
summary(sfo.shortdistance.model)$r.squared

# obtenim les dades del model i el valor de R squared
sfo.longdistance.model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data = sfo.clean.long)
coef(sfo.longdistance.model)

# el valor de R squared
summary(sfo.longdistance.model)$r.squared
```

Amb els vols amb més distància tenim un model de millor qualitat que amb els vols més curts. Sembla que els vols més curts no expliquen el perquè s'endarrereixen les sortides en canvi els vols llargs sí que ho fan ja que millorem el model en un 3% respecte l'inicial sense la variable DISTANCE. 

## Model de regressió lineal múltiple (regresors quantitatius i qualitatius)

Anem a realitzar un estudi ara amb les variables explicatives ARRIVAL_DELAY i LATE_AIRCRAFT_DELAY  (> 15 minuts o <= 15 minuts) i la variable explicada DEPARTURE_DELAY.

El primer que farem és eliminar els registres NA de LATE_AIRCRAFT_DELAY

```{r}
sfo.clean <- subset(sfo.clean, !is.na(sfo.clean$LATE_AIRCRAFT_DELAY))
```

Ara crearem una variable a partir de LATE_AIRCRAFT_DELAY(> 15 minuts o <= 15 minuts), serà 1 si LATE_AIRCRAFT_DELAY > 15 minuts, altrament serà 0.

```{r}
sfo.clean$LATE_AIRCRAFT_DELAY_BOOL <- ifelse(sfo.clean$LATE_AIRCRAFT_DELAY > 15, 1, 0)
```

Ara ja podem realitzar el model:

```{r}
sfo.model3 = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + LATE_AIRCRAFT_DELAY_BOOL, data = sfo.clean)
coef(sfo.model3)

summary(sfo.model3)$r.squared
```
Tenim una equació de la forma: yi = 0.9331936 + 0.9620261 * ARRIVAL_DELAY  + 6.5654644* LATE_AIRCRAFT_DELAY_BOOL

La qualitat de l'ajust segons el coeficient de determinació R square és de 0.9419076. És a dir tenim un molt bon ajust.

## Diagnosi del model

Anem a fer un diagnosi del model trobat en l'apartat 2.1.b. Per això fem dues gràfiques, un amb els valors estimats enfront dels residus, per poder veure si la variança es constant i el gràfic quantil-quantil per comparar els resudis del model amb els valors d'una variable normal.

El primer que farem és arrencar el dataset amb tots els elements (en el pas previ 1.2 hem eliminat alguns NA's que en el 1.1.b ens poden servir), i eliminem els NA's de ARRIVAL_DELAY.

```{r}
sfo.clean <- subset(sfo, !is.na(sfo$ARRIVAL_DELAY))
```

Afegirem una columna amb els valors estimats (fem servir el model estimat a l'apartat 1.1.b)

```{r}
sfo.clean$yi<- 2.35 + (9.246e-01 * sfo.clean$ARRIVAL_DELAY) + (2.904e-03 * sfo.clean$DISTANCE)
```

Afegim una altre columna amb els residus.

```{r}
sfo.clean$ri <- sfo.clean$DEPARTURE_DELAY - sfo.clean$yi
```

### Gràfic dels resudis enfront valors estimats

```{r}
plot(x = sfo.clean$yi, y = sfo.clean$ri)
```

Hem mostrat els residus enfront dels valors estimats i sí que sembla que tinguem una estructura per tant sembla que no sigui adecuat el model. La gran majoria estàn al voltant de 0 però altres és disparen fins a valors d'error per sota de -150.


### Valors dels resudis enfront la variable

```{r}
plot(x = sfo.clean$DEPARTURE_DELAY, y = sfo.clean$ri)
```

Ens passa exactament el mateix quan enfrontem el valor dels residus davant de la variable explicativa DEPARTURE_DELAY.

```{r}
plot(x = sfo.clean$DISTANCE, y = sfo.clean$ri)
```

En canvi la variable DISTANCE si que sembla que no tingui cap estructura encara que hi han valors al voltant de 0 i altres que no tant.


```{r}
model = lm(DEPARTURE_DELAY ~ ARRIVAL_DELAY + DISTANCE, data=sfo.clean)
summary(model)
model.stdres = rstandard(model)
qqnorm(model.stdres, 
     ylab="Standardized Residuals", 
     xlab="Normal Scores", 
     main="QQ Plot") 
qqline(model.stdres)
```
Finalement hem executat QQ plot per saber si els errors és distribueixen de forma normal. En el mig del gràfic sembla que així sigui però es va convant en els extrems. Aquests tipus de gràfics poden indicar que tenim valors extrems del que esperariem d'una distribucó normal.

## Predicció del model

Ara anem a predir el retard d'un avió que un cop ha recorregut 2500 milles (DISTANCE) ha arribat al seu destí amb 30 minuts més tard (ARRIVAL_DELAY).

```{r}
prediction.departure.delay <- 2.35 + (9.246e-01 * 30) + (2.904e-03 * 2500)
paste('Segons el model que hem calculat l\'avió sortirà amb un retard de:',prediction.departure.delay, 'minuts')
```


*****
# Model de regressió logística
*****

Estudiarem la probabilitat de que un avió tingui un retard.

## Estudi de relacions entre variables

Anem a crear una nova variable, DELAY_SFO. Aquesta variable és 1, si l'avió surt amb més de 15 minuts de retard (DEPARTURE_DELAY >= 15), altrament serà 0. Eliminarem els valors NA's de LATE_AIRCRAFT_DELAY.

```{r}
sfo.delay <- subset(sfo, !is.na(sfo$LATE_AIRCRAFT_DELAY))
sfo.delay$DELAY_SFO <-ifelse(sfo.delay$LATE_AIRCRAFT_DELAY >= 15, 1, 0)
```

Transformem els atributs com a factor:

```{r}
sfo.delay$DAY_OF_WEEK <- as.factor(sfo.delay$DAY_OF_WEEK)
sfo.delay$DELAY_SFO <- as.factor(sfo.delay$DELAY_SFO)
sfo.delay$AIRLINE <- as.factor(sfo.delay$AIRLINE)
```


### Visualizem relació entre DELAY_SFO i la variables DAY_OF_WEEK.

Anem a visualitzar DELAY_SFO enfront de DAY_OF_WEEK:

```{r}
ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK,fill=DELAY_SFO)) + geom_bar()

ggplot(data=sfo.delay,aes(x=DAY_OF_WEEK, fill=DELAY_SFO)) + geom_bar(position="fill")
```


Tenim dos gràfiques, la primera amb valors absoluts i la segona amb els valors normalitzats. El nombre de vols és similar en quasi tots els dies. El dia que menys hi han són el dia 6 i 3 que justament coincideix amb els dies que hi han menys endarreriments. 

Per tant, seria una bona variable per a trobar una relació. La quantitat de vols diaris o l'hora  podria afectar a l'endarreriment.


### Visualizem relació entre DELAY_SFO i la variable AIRLANE.

```{r}
ggplot(data=sfo.delay,aes(x=AIRLINE,fill=DELAY_SFO)) + geom_bar()

ggplot(data=sfo.delay,aes(x=AIRLINE, fill=DELAY_SFO)) + geom_bar(position="fill") + ylab("Probability")

```

Fem el mateix perà ara amb AIRLANE. Tenim dues companyies (HA, US) que tenen un rati de endarreriments molt més baix, però també tenen menys vols. Concretament HA té molt pocs vols i cap endarreriment. Hi han altres que tenen pocs vols (F9) però la proporció d'endarreriments és similar a les altres.

Apliquem el test de Chi Quadrat (χ2) de Pearson per avaluar la dependencia entre les variables. Aquest test s'aplica normalement amb variables categòriques que és el nostre cas.


* Ho: Les variables són depenents.

* H1: Les variables són independents.


Primer l'apliquem sobre DAY_OF_WEEK:


```{r}
table <-table(sfo.delay$DAY_OF_WEEK, sfo.delay$DELAY_SFO)
table

chisq.test(table, correct=FALSE)
```
El valor de p-value és de 2.2e-16, per tant no podem rebutjar la hipòtesi nul·la i assumim que les variables són depenents.


Ara fem el mateix amb AIRLANE:


```{r}
table <-table(sfo.delay$AIRLINE, sfo.delay$DELAY_SFO)
table

chisq.test(table, correct=FALSE)
```
Tenim exactament el mateix resultat per tant les dues variables ens poden servir per a inferir si els vols s'endarreriran més de 15 minuts en la sortida o no, segons els valors d'AIRLINE i DAY_OF_WEEK.

## Model de regressió logística

### DAY_OF_WEEK

Model de regressió DELAY_SFO x DAY_OF_WEEK amb dia de referència dilluns.


```{r}
model.logist1=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK, family=binomial(link=logit))
summary(model.logist1)
```

Han calgut un total de 4 iteracions per a estimar els paràmetres.

La variable DAY_OF_WEEK és significativa ja que el valor de Pr(>|z|) < 0.05. 

Calcularem també els intervals de confiança. Com més gran siguin aquests intervals més ineficient serà el model o estimació del paràmetre:

```{r}
confint(model.logist1)
```
Aquests valors són els que poden prendre les variables entre el 2.5% i el 97.5%.


Calculem els OR (Odds Ratio) per la variable DAY_OF_WEEK:

```{r}
exp(coefficients(model.logist1))
```


Que un vol s'endarrereixi en la sortida en dimarts és 0.83 vegades menys probable que en dilluns.


### AIRLINE

Ara fem el mateix exercici però amb la variable explicativa AIRLINE.

```{r}
model.logist2=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$AIRLINE, family=binomial(link=logit))
summary(model.logist2)
```

En aquest cas hem tingut 13 iteracions. La variable AIRLINE és significativa ja que el valor de Pr(>|z|) < 0.05. 

Calcularem també els intervals de confiança. Com més gran siguin aquests intervals més ineficient serà el model o estimació del paràmetre.


```{r}
confint(model.logist2)
```

Calculem els OR:

```{r}
exp(coefficients(model.logist2))
```

Per exemple, podem veure que AIRLINE AS és aproximadament 2, per el que podem dir que s'endarrereixi la sortida del vol amb aquesta aerolínea comparat amb la aerolínia AA és 2 vegades major.

### DAY_OF_WEEK i DISTANCE

Ara fem un tercer model amb les dues variables explicatives DAY_OF_WEEK i DISTANCE i la variable dependent DELAY_SFO.

```{r}
model.logist3=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$DISTANCE, family=binomial(link=logit))
summary(model.logist3)
```
Tenim un AIC de 59266 < 59493. 

Si veiem els valors estimats no hi han grans canvis. Per exemple en el dimarts (DAY_OF_WEEK2) passem del -0.18731 a -1.870e-01 (que és el mateix valor). No està canviant el DAY_OF_WEEK al introduir la distància. No sembla doncs que sigui una variabla de confusió la distància.

Calculem els OR:

```{r}
exp(coefficients(model.logist3))
```

Tenim un OR en la variabla distància de 0.99969 (aproximadament 1) per el que **no hi ha relació entre la variable distància i la explicada. No considerem doncs la variable distància com a significativa** i no l'afegirem en el següent exercici.


### DAY_OF_WEEK + AIRLANE

En el quart model anem a afegir a les variables explicatives les significatives dels apartats anteriors.

```{r}
model.logist4=glm(formula=sfo.delay$DELAY_SFO ~ sfo.delay$DAY_OF_WEEK + sfo.delay$AIRLINE , family=binomial(link=logit))
summary(model.logist4)
```

Tornem a tenir una millora en el model, ja que al afegir les variables tenim un AIC encara per sota dels anteriors.

Calcularem els OR.

```{r}
exp(coefficients(model.logist4))
```

## Predicció

Anem a predir la probabilitat de retard en el vol, si el destí està a 1500 milles i viatjem en dijous:

```{r}
model.logist.predict=glm(data=sfo.delay, formula=DELAY_SFO ~ DAY_OF_WEEK + DISTANCE, family=binomial(link=logit))
data <- data.frame(DAY_OF_WEEK='4',DISTANCE=1500)
pred<-predict(model.logist.predict, data,type ="response")
pred
```
La predicció de retard en el vol en dijous (DAY_OF_WEEK = 4) i distància de 1500 milles és de 0.25. És a dir hi han un 25% de probabilitat de que el vol arribi amb més de 15 minuts del temps previst.

## Bondat de l’ajust

Anem a aplicar el test de Hosman-Lemeshow per a calcular la bondat de l'ajust del model del punt [3.2.3](#day_of_week-i-distance). Fem servir aquest test ja que una de les variables és contínua. 

Comparem els valors previstos (esperats) amb els observats. Fem un contrast d'hipòtesi on la nul·la ens diu que no hi ha  diferències entre els valors per tant la alternativa indica que el model no és correcte.

```{r}
model.logist=glm(data=sfo.delay, formula=sfo.delay$DELAY_SFO~sfo.delay$DAY_OF_WEEK+sfo.delay$DISTANCE, family=binomial(link=logit))
hoslem.test(sfo.delay$DELAY_SFO,fitted(model.logist))
```

Amb el p-value < 0.05 rebutgem la hipòtesi nul·la amb el que el model no ajusta bé les dades.

## Corba ROC

Anem a fer servir l'anàlisi ROC per a trobar la qualitat dels models [3.2.3](#day_of_week-i-distance) i [3.2.4](#day_of_week-airlane):

### Anàlisi ROC 1 (DAYS_OF_WEEK + DISTANCE)

```{r}
prob=predict(model.logist3, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot (r)
auc(r)
```

Tenim un model amb una àrea per sata de la corba de 0.5971, per tant el model no prediu gaire bé les dades.

### Anàlisi ROC 2 (DAYS_OF_WEEK + AIRLANE)

```{r}
prob=predict(model.logist4, sfo.delay, type="response")
r=roc(sfo.delay$DELAY_SFO, prob, data=sfo.delay)
plot(r)
auc(r)
```

Amb el segon model tenim una millora encara que no és molt significativa.



*****
# Conclusions de l’anàlisi
*****

## Regressió lineal

En l'estudi del model mitjantçant la regressió lineal hem pogut veure visualment que existeix una relació entre l'endarreriment de la sortida i l'endarreriment de l'arribada. Té sentit ja que si un vol arriba tard pot implicar que el següent (amb el mateix avió) surti tard.

Amb el càlcul de la suma de quadrats i posteriorment amb el R-Square (coeficient de determinació) proper a 1, hem vist que les variables estan fortament relacionades.

Afegint la variable DISTANCE la millora del model no és molt significativa i per a simplificar el model no la inclouria. Però si dividim els vols entre els curts i els llargs si que obtenim millora. Els vols llargs donan una resposta a perquè els vols s'endarrereixen millor que no pas els curts.

Amb el model de regressió lineal múltiple hem creat un model amb ARRIVAL_DELAY i un boolean que diu si hi ha retard per arribada tard de l'avió. Aquest model té molt millor ajust i millorem el model.

Quan mostrem les gràfiques del model lineal simple amb els residus, tenim un patró visual similar amb valors propers a 0 però que hi han valors que és disparen. Amb el QQPlot hem pogut veure que és probable que tinguem outliers que desvirtuen els models.


## Regressió logística

Amb una estudi visual podem veure que tant DAY_OF_WEEK com AIRLINE tenen valors que poden donar resposta a prediccions. Per exemple, els dimarts i dissabtes són millors dies. Però si mirem en nombre de vols per dia aquests dies hi han menys vols. Per tant podria ser que els dies que hi han menys vols tenim menys endarreriments.

Fent el test de Chi Quadrat hem conclós que ambdues variables són depenents.

Estudiant els models, totes les variables ens han resultat significatives excepte DISTANCE que calculant l'OR ens donava al voltant de 1. Amb aquest valor preferim simplificar el model i deixar com explicatives DAY_OF_WEEK i AIRLANE ja que realment DISTANCE ens aporta poc.













